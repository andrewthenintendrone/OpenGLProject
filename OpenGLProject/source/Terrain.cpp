#include "Terrain.h"
#include <iostream>
#include <fstream>
#include <random>
#include "PerlinNoise.h"
#include <fstream>

// returns a random float between min and max
float frand(float min, float max)
{
	float f = (float)rand() / RAND_MAX;
	return min + f * (max - min);
}

Terrain::Terrain(unsigned int gridSizeX, unsigned int gridSizeY) : m_gridSizeX(gridSizeX), m_gridSizeY(gridSizeY)
{
	m_heights = Array2D<float>(m_gridSizeX, m_gridSizeY);
}

// generate terrain using perlin noise
void Terrain::generatePerlin()
{
	for (unsigned int x = 0; x < m_gridSizeX; x++)
	{
		for (unsigned int y = 0; y < m_gridSizeY; y++)
		{
			float perlin = PerlinNoise::getInstance().octavePerlin(x * 0.01f, y * 0.01f, 6, 0.75f);

			m_heights(x, y) += perlin;
		}
	}

	init();
}

// read raw terrain file generated by unity etc
void Terrain::readRaw(const std::string& filename)
{
	// open file
	std::ifstream file;
	file.open(filename, std::ios::_Nocreate | std::ios::binary);

	// check if file opened correctly
	if (!file.is_open())
	{
		std::cout << "Failed to open " << filename << std::endl;
		return;
	}

	// read heights from file
	for (unsigned int y = 0; y < m_gridSizeY; y++)
	{
		for (unsigned int x = 0; x < m_gridSizeX; x++)
		{
			uint16_t currentHeight;

			file.read(reinterpret_cast<char*>(&currentHeight), sizeof(uint16_t));
			m_heights(x, y) = (float)currentHeight;
		}
	}

	// close file
	file.close();

	// initialise
	init();
}

void Terrain::generateRandom()
{
	for (unsigned int x = 0; x < m_gridSizeX; x++)
	{
		for (unsigned int y = 0; y < m_gridSizeY; y++)
		{
			float random = frand(0, 1);

			m_heights(x, y) = random;
		}
	}

	init();
}

// calculate the direction of a triangle
glm::vec3 Terrain::getTriangleDirection(glm::vec3 p1, glm::vec3 p2, glm::vec3 p3)
{
	return glm::cross(p2 - p1, p3 - p1);
}

// create mesh data
void Terrain::init()
{
	// create vectors for vertices and indices
	std::vector<Vertex> verts;
	std::vector<unsigned int> indices;

	// generate mesh
	for (unsigned int x = 0, i = 0; x < m_gridSizeX; x++)
	{
		for (unsigned int y = 0; y < m_gridSizeY; y++, i++)
		{
			Vertex currentVertex;

			// sample heights
			float currentHeight = m_heights(x, y);

			// set vertex position
			currentVertex.position = glm::vec4(x - m_gridSizeX / 2.0f, currentHeight, y - m_gridSizeY / 2.0f, 1.0f);

			// set texture coordinates (currently unused)
			currentVertex.texcoord = glm::vec2((float)x / (float)m_gridSizeX, (float)y / (float)m_gridSizeY);

			verts.push_back(currentVertex);

			// create triangles
			if (x < m_gridSizeX - 1 && y < m_gridSizeY - 1)
			{
				int i2 = i + 1;
				int i3 = i + m_gridSizeX;
				int i4 = i + m_gridSizeX + 1;

				indices.push_back(i);
				indices.push_back(i2);
				indices.push_back(i4);

				indices.push_back(i4);
				indices.push_back(i3);
				indices.push_back(i);
			}
		}
	}

	// calculate vertex normals
	for (unsigned int x = 0, i = 0; x < m_gridSizeX; x++)
	{
		for (unsigned int y = 0; y < m_gridSizeY; y++, i++)
		{
			if (x > 0 && x < m_gridSizeX - 1 && y > 0 && y < m_gridSizeY - 1)
			{
				// average triangle directions for normal
				glm::vec3 d1 = getTriangleDirection(verts[i - m_gridSizeX - 1].position, verts[i - m_gridSizeX].position, verts[i].position);
				glm::vec3 d2 = getTriangleDirection(verts[i - m_gridSizeX].position, verts[i + 1].position, verts[i].position);
				glm::vec3 d3 = getTriangleDirection(verts[i].position, verts[i + 1].position, verts[i + m_gridSizeX + 1].position);
				glm::vec3 d4 = getTriangleDirection(verts[i + m_gridSizeX + 1].position, verts[i + m_gridSizeX].position, verts[i].position);
				glm::vec3 d5 = getTriangleDirection(verts[i - 1].position, verts[i].position, verts[i + m_gridSizeX].position);
				glm::vec3 d6 = getTriangleDirection(verts[i].position, verts[i - m_gridSizeX - 1].position, verts[i - m_gridSizeX].position);

				glm::vec3 average = (d1 + d2 + d3 + d4 + d5 + d6) / 6.0f;

				verts[i].normal = glm::vec4(glm::normalize(average), 0);
				verts[i].tangent = glm::vec4(glm::cross(glm::vec3(verts[i].normal), glm::vec3(0, 1, 0)), 0);
			}
		}
	}

	initialise(verts, &indices);
}
